PSEUDOCODE

callback_function()
	update state (once)
	update timing (once)

	get state from data
	take action from policy_function 
	[simulate - ends callback]
	get next state from data
	get reward from state/action via reward_function
	update policy_function


# but we need the simulation to be the last step

callback_function()
	update state (once)
	update timing (once)

	get prior state from data
	get prior action from data
	get reward from prior state/action via reward_function
	update policy_function

	get current state from data
	take action from policy_function 
	[simulate - ends callback]

	
# including more logic and requirements

callback_function()
	
	(one time per sim operations)

	if first timestep per zone (if not pre-env calling point  - use list):
		update state (once per timestep)
		update timing (once per timestep)

	--- {RL func} ---
	if not first state - data > 1 entry:
		get prior state from data
		get prior action from data

		get reward from prior state/action via reward_function
		get policy_function
		update policy_function (save params)

	get current state from data
	get updated policy_function
	get action from policy_function using current state (use params)
	return action
	--- {end} ---

	take action
	[simulate - ends callback]


# adding @decorator functions



decorator func(*RL dependencies)
	
	callback_function()

		(one time per sim operations)

		if first timestep per zone (if not pre-env calling point  - use list):
			update state (once per timestep)
			update timing (once per timestep)

		RL_func(*RL dependencies)

			if not first state - data > 1 entry:
				get prior state from data
				get prior action from data

				get reward from prior state/action via reward_function
				get policy_function
				update policy_function (save params)


			get current state from data
			get updated policy_function
			get action from updated policy_function using current state (use params)
			return action

		take action
		[simulate - ends callback]


user creates RL function that only uses self.X inputs and returns actions??? How should it store data



def outter(self, *args, **kwargs):

    def _callback_function(self, state_arg):

        # get handles once --------------------------------------------------------------------------------------------
        if not self.got_ems_handles:
            # verify ems objects are ready for access, skip until
            if not self.api.exchange.api_data_fully_ready(state_arg):
                return  # TODO will this be an issue for @decorators??? don't think so
            self._set_ems_handles()
            self.got_ems_handles = True

        # skip if simulation in warmup --------------------------------------------------------------------------------
        if self.api.exchange.warmup_flag(state_arg):
            # TODO can I utilize this as a single that only timestep calling points are from this point onward???
            return

        # update & append simulation data [DO ONCE per timestep, in right place] --------------------------------------
        if not self.done_per_timestep:
            self._update_time()  # note timing update is first
            self._update_ems_vals()
            self._update_weather_vals()

        # timing & count updates [DO ONCE per timstep] ----------------------------------------------------------------
        self.count += 1
        self.zone_ts += 1  # TODO make dependent on input file OR handle mistake where user enters incorrect ts
        if self.zone_ts > self.timestep_freq:
            self.zone_ts = 1